-------------> ZOD <--------------
import * as z from "zod"; 
 
const Player = z.object({ 
  username: z.string(),
  xp: z.number()
});

Given any Zod schema, use .parse to validate an input. 
If it's valid, Zod returns a strongly-typed deep clone of the input.
Player.parse({ username: "billie", xp: 100 }); 
// => returns { username: "billie", xp: 100 }

await Player.parseAsync({ username: "billie", xp: 100 }); 

Handling errors
When validation fails, the .parse() method will throw a ZodError instance with granular 
information about the validation issues.

try {
  Player.parse({ username: 42, xp: "100" });
} catch(error){
  if(error instanceof z.ZodError){
    error.issues; 
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}

To avoid a try/catch block, you can use the .safeParse() method to get back a plain result object 
containing either the successfully parsed data or a ZodError.
const result = Player.safeParse({ username: 42, xp: "100" });
if (!result.success) {
  result.error;   // ZodError instance
} else {
  result.data;    // { username: string; xp: number }
}



In Zod, z.infer is a utility type used to extract the static TypeScript type from a Zod schema. 
Zod schemas are runtime validation objects, but they also carry rich type information that 
TypeScript can leverage at compile time.
How z.infer works:-
Define a Zod Schema: You first define your data structure using Zod's schema builders 
(e.g., z.object(), z.string(), z.array()).

    import { z } from 'zod';

    const UserSchema = z.object({
      id: z.string().uuid(),
      name: z.string().min(1),
      email: z.string().email(),
      age: z.number().int().positive(),
    });

Infer the Type: You then use z.infer<typeof YourSchema> to get the corresponding TypeScript type.


    type User = z.infer<typeof UserSchema>;

    // User will be inferred as:
    // type User = {
    //   id: string;
    //   name: string;
    //   email: string;
    //   age: number;
    // };

Primitives:
z.string(): For string values. Can be combined with modifiers like .min(), .max(), .email(), .url().
z.number(): For numeric values. Can be combined with modifiers like .min(), .max(), .int(), .positive().
z.boolean(): For boolean values (true/false).
z.date(): For Date objects.
z.bigint(): For BigInt values.
z.symbol(): For Symbol values.
Empty Types:
z.undefined(): Represents the undefined type.
z.null(): Represents the null type.
z.void(): Represents the void type (often used in function return types).
Special Types:
z.any(): Allows any value, effectively bypassing type checking for that field.
z.unknown(): Similar to any but requires type narrowing before use.
z.never(): Indicates that a value should never occur, useful for exhaustive type checking.
Complex Types:
z.object(): To define an object schema, containing other Zod schemas for its properties.
z.array(): To define an array of a specific type.
z.union(): To allow a field to be one of several specified types.
z.enum(): To define a field that must be one of a set of predefined string values.
z.literal(): To define a field that must be a specific literal value (e.g., z.literal("hello")).
Making Fields Optional:
By default, all fields in a Zod schema are required. To make a field optional, the .optional() modifier is appended to its schema definition.



--------------------> File System <---------------
import fs from "fs";

// Write file
fs.writeFileSync("example.txt", "Hello World");

// Read file
const data = fs.readFileSync("example.txt", "utf-8");
console.log(data);

// Delete file
fs.unlinkSync("example.txt");


Typical scenarios:
1) File Uploads [Files are either stored locally or uploaded directly to cloud storage]
2) File Downloads/Serving [Serving files to clients.Example: sending a PDF report to the user.]
3)Static Files:- Serving images, CSS, JS via express.static() or CDNs.
4) File Streams (Efficient Reading/Writing) Useful for large files (e.g., videos, logs).Streams prevent loading entire file into memory.
5) File Metadata File size, type, creation time, etc. (fs.statSync).

3. Industry Best Practices in File Handling

Here’s what most companies follow:

Storage Strategies

Do not store large files directly on your server’s disk.

Local storage is fine for development or small apps, but not scalable.

Use cloud storage:

Amazon S3, Google Cloud Storage, Azure Blob Storage.

Store only file URLs/paths in your database, not the file itself.

Content Delivery Network (CDN) for faster access worldwide.

File Upload Practices
Validate file type & size (security + performance).
Sanitize file names
Use unique identifiers (UUID, timestamp) instead of original filenames to avoid conflicts.
File Security
Never trust user input paths (avoid ../ attacks).
Use private buckets for sensitive files and generate signed URLs with expiry times.
Set proper file permissions (read/write/execute).
Performance
Use streams for large files instead of reading entire file into memory.
Compress files before storage (gzip, WebP for images).
Offload media-heavy workloads to specialized services (e.g., Cloudinary for images/videos).
Database Integration
Store metadata only (file name, size, type, URL, owner).

Example table:
CREATE TABLE files (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  filename TEXT,
  mimetype TEXT,
  size INT,
  url TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

Logging & Monitoring
Log file access (who uploaded/downloaded).
Monitor storage size (to avoid exceeding quotas)


fs.writeFile("example.txt", "Hello, Node.js!", (err) => {
  if (err) throw err;
  console.log("File created & data written!");
});
fs.writeFileSync("example.txt", "Hello, Node.js!");
console.log("File created & data written!");
Use writeFile for creating new files or replacing content.
If file already exists → content will be overwritten.

fs.appendFile("example.txt", "\nThis is new content.", (err) => {
  if (err) throw err;
  console.log("Content appended!");
});

fs.readFile("example.txt", "utf-8", (err, data) => {
  if (err) throw err;
  console.log("File content:", data);
});
const data = fs.readFileSync("example.txt", "utf-8");
console.log("File content:", data);

fs.unlink("example.txt", (err) => {
  if (err) throw err;
  console.log("File deleted!");
});

fs.rename("example.txt", "renamed.txt", (err) => {
  if (err) throw err;
  console.log("File renamed!");
});

fs.stat("renamed.txt", (err, stats) => {
  if (err) throw err;
  console.log("File size:", stats.size);
  console.log("Created:", stats.birthtime);
});

// Create folder
fs.mkdir("myFolder", (err) => {
  if (err) throw err;
  console.log("Folder created!");
});

// Delete folder
fs.rmdir("myFolder", (err) => {
  if (err) throw err;
  console.log("Folder deleted!");
});

fs.readdir(".", (err, files) => {
  if (err) throw err;
  console.log("Files in current folder:", files);
});

Streams (For Large Files)
Instead of loading the whole file in memory → use streams.
const readStream = fs.createReadStream("bigfile.txt", "utf-8");
readStream.on("data", (chunk) => {
  console.log("Chunk:", chunk);
});

DiskStorage → Saves files to local server (not scalable for production).
MemoryStorage → Keeps file in memory buffer, then you upload it to cloud storage (S3, GCS, etc.).



    // const uploadedFile = req.file;
    // if (!uploadedFile) {
    //   return res.status(400).json({ error: "No file uploaded." });
    // }
    let imageUrl: string | null = null;
    // if (req.file) {
    //   imageUrl = `/public/temp${Date.now()}-${req.file.originalname}`;
    //   console.log(req.file);
    //   console.log(req.body);
    // }


//product 

{
    "categoryId": 1,
    "productName": "iPhone 12 Pro",
    "description": "Latest Apple iPhone with A16 Bionic chip",
    "brand": "Apple",
    "skus":[
      {
         "productId": 1,
         "attributes": { "storage": "256GB", "color": "Silver" },
         "skuCode": "IPH12PRO-128-SLR",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 80,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      },
      {
         "productId": 1,
         "attributes": { "storage": "128GB", "color": "Space" },
         "skuCode": "IPH12PRO-128-SPC",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 170,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      },
      {
         "productId": 1,
         "attributes": { "storage": "128GB", "color": "YELLOW" },
         "skuCode": "IPH12PRO-128-YLW",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 120,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      }

    ]

}


//           ACTIVATE/DEACTIVATE
        await prisma.sku.update({
      where: { id: parseInt(id) },
      data: {
        isActive: JSON.parse(status),
      },
    });
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    