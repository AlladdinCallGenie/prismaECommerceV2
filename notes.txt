-------------> ZOD <--------------
import * as z from "zod"; 
 
const Player = z.object({ 
  username: z.string(),
  xp: z.number()
});

Given any Zod schema, use .parse to validate an input. 
If it's valid, Zod returns a strongly-typed deep clone of the input.
Player.parse({ username: "billie", xp: 100 }); 
// => returns { username: "billie", xp: 100 }

await Player.parseAsync({ username: "billie", xp: 100 }); 

Handling errors
When validation fails, the .parse() method will throw a ZodError instance with granular 
information about the validation issues.

try {
  Player.parse({ username: 42, xp: "100" });
} catch(error){
  if(error instanceof z.ZodError){
    error.issues; 
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}

To avoid a try/catch block, you can use the .safeParse() method to get back a plain result object 
containing either the successfully parsed data or a ZodError.
const result = Player.safeParse({ username: 42, xp: "100" });
if (!result.success) {
  result.error;   // ZodError instance
} else {
  result.data;    // { username: string; xp: number }
}



In Zod, z.infer is a utility type used to extract the static TypeScript type from a Zod schema. 
Zod schemas are runtime validation objects, but they also carry rich type information that 
TypeScript can leverage at compile time.
How z.infer works:-
Define a Zod Schema: You first define your data structure using Zod's schema builders 
(e.g., z.object(), z.string(), z.array()).

    import { z } from 'zod';

    const UserSchema = z.object({
      id: z.string().uuid(),
      name: z.string().min(1),
      email: z.string().email(),
      age: z.number().int().positive(),
    });

Infer the Type: You then use z.infer<typeof YourSchema> to get the corresponding TypeScript type.


    type User = z.infer<typeof UserSchema>;

    // User will be inferred as:
    // type User = {
    //   id: string;
    //   name: string;
    //   email: string;
    //   age: number;
    // };

Primitives:
z.string(): For string values. Can be combined with modifiers like .min(), .max(), .email(), .url().
z.number(): For numeric values. Can be combined with modifiers like .min(), .max(), .int(), .positive().
z.boolean(): For boolean values (true/false).
z.date(): For Date objects.
z.bigint(): For BigInt values.
z.symbol(): For Symbol values.
Empty Types:
z.undefined(): Represents the undefined type.
z.null(): Represents the null type.
z.void(): Represents the void type (often used in function return types).
Special Types:
z.any(): Allows any value, effectively bypassing type checking for that field.
z.unknown(): Similar to any but requires type narrowing before use.
z.never(): Indicates that a value should never occur, useful for exhaustive type checking.
Complex Types:
z.object(): To define an object schema, containing other Zod schemas for its properties.
z.array(): To define an array of a specific type.
z.union(): To allow a field to be one of several specified types.
z.enum(): To define a field that must be one of a set of predefined string values.
z.literal(): To define a field that must be a specific literal value (e.g., z.literal("hello")).
Making Fields Optional:
By default, all fields in a Zod schema are required. To make a field optional, the .optional() modifier is appended to its schema definition.



--------------------> File System <---------------
import fs from "fs";

// Write file
fs.writeFileSync("example.txt", "Hello World");

// Read file
const data = fs.readFileSync("example.txt", "utf-8");
console.log(data);

// Delete file
fs.unlinkSync("example.txt");


Typical scenarios:
1) File Uploads [Files are either stored locally or uploaded directly to cloud storage]
2) File Downloads/Serving [Serving files to clients.Example: sending a PDF report to the user.]
3)Static Files:- Serving images, CSS, JS via express.static() or CDNs.
4) File Streams (Efficient Reading/Writing) Useful for large files (e.g., videos, logs).Streams prevent loading entire file into memory.
5) File Metadata File size, type, creation time, etc. (fs.statSync).

3. Industry Best Practices in File Handling

Hereâ€™s what most companies follow:

Storage Strategies

Do not store large files directly on your serverâ€™s disk.

Local storage is fine for development or small apps, but not scalable.

Use cloud storage:

Amazon S3, Google Cloud Storage, Azure Blob Storage.

Store only file URLs/paths in your database, not the file itself.

Content Delivery Network (CDN) for faster access worldwide.

File Upload Practices
Validate file type & size (security + performance).
Sanitize file names
Use unique identifiers (UUID, timestamp) instead of original filenames to avoid conflicts.
File Security
Never trust user input paths (avoid ../ attacks).
Use private buckets for sensitive files and generate signed URLs with expiry times.
Set proper file permissions (read/write/execute).
Performance
Use streams for large files instead of reading entire file into memory.
Compress files before storage (gzip, WebP for images).
Offload media-heavy workloads to specialized services (e.g., Cloudinary for images/videos).
Database Integration
Store metadata only (file name, size, type, URL, owner).

Example table:
CREATE TABLE files (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  filename TEXT,
  mimetype TEXT,
  size INT,
  url TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

Logging & Monitoring
Log file access (who uploaded/downloaded).
Monitor storage size (to avoid exceeding quotas)


fs.writeFile("example.txt", "Hello, Node.js!", (err) => {
  if (err) throw err;
  console.log("File created & data written!");
});
fs.writeFileSync("example.txt", "Hello, Node.js!");
console.log("File created & data written!");
Use writeFile for creating new files or replacing content.
If file already exists â†’ content will be overwritten.

fs.appendFile("example.txt", "\nThis is new content.", (err) => {
  if (err) throw err;
  console.log("Content appended!");
});

fs.readFile("example.txt", "utf-8", (err, data) => {
  if (err) throw err;
  console.log("File content:", data);
});
const data = fs.readFileSync("example.txt", "utf-8");
console.log("File content:", data);

fs.unlink("example.txt", (err) => {
  if (err) throw err;
  console.log("File deleted!");
});

fs.rename("example.txt", "renamed.txt", (err) => {
  if (err) throw err;
  console.log("File renamed!");
});

fs.stat("renamed.txt", (err, stats) => {
  if (err) throw err;
  console.log("File size:", stats.size);
  console.log("Created:", stats.birthtime);
});

// Create folder
fs.mkdir("myFolder", (err) => {
  if (err) throw err;
  console.log("Folder created!");
});

// Delete folder
fs.rmdir("myFolder", (err) => {
  if (err) throw err;
  console.log("Folder deleted!");
});

fs.readdir(".", (err, files) => {
  if (err) throw err;
  console.log("Files in current folder:", files);
});

Streams (For Large Files)
Instead of loading the whole file in memory â†’ use streams.
const readStream = fs.createReadStream("bigfile.txt", "utf-8");
readStream.on("data", (chunk) => {
  console.log("Chunk:", chunk);
});

DiskStorage â†’ Saves files to local server (not scalable for production).
MemoryStorage â†’ Keeps file in memory buffer, then you upload it to cloud storage (S3, GCS, etc.).



    // const uploadedFile = req.file;
    // if (!uploadedFile) {
    //   return res.status(400).json({ error: "No file uploaded." });
    // }
    let imageUrl: string | null = null;
    // if (req.file) {
    //   imageUrl = `/public/temp${Date.now()}-${req.file.originalname}`;
    //   console.log(req.file);
    //   console.log(req.body);
    // }


//product 

{
    "categoryId": 1,
    "productName": "iPhone 12 Pro",
    "description": "Latest Apple iPhone with A16 Bionic chip",
    "brand": "Apple",
    "skus":[
      {
         "productId": 1,
         "attributes": { "storage": "256GB", "color": "Silver" },
         "skuCode": "IPH12PRO-128-SLR",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 80,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      },
      {
         "productId": 1,
         "attributes": { "storage": "128GB", "color": "Space" },
         "skuCode": "IPH12PRO-128-SPC",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 170,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      },
      {
         "productId": 1,
         "attributes": { "storage": "128GB", "color": "YELLOW" },
         "skuCode": "IPH12PRO-128-YLW",
         "productPrice": 999.99,
         "discount": 50.00,
         "stock": 120,
         "image": "https://example.com/images/iphone14-black-128.jpg"
      }

    ]

}


//           ACTIVATE/DEACTIVATE
        await prisma.sku.update({
      where: { id: parseInt(id) },
      data: {
        isActive: JSON.parse(status),
      },
    });
    
    
    
//    PLACE ORDER CONTROLLER FOR CHECKOUT ..... 
    
export const placeOrder = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user) return res.status(401).json({ message: "Login required" });
    const userId = req.user.id;
    const { addressId, couponCode } = req.body;

    const cart = await prisma.cart.findUnique({
      where: { userId },
      include: { cartItem: true },
    });

    if (!cart || cart.cartItem.length === 0)
      return res.status(400).json({ message: "Cart is Empty.." });

    const address = await prisma.userAddress.findFirst({
      where: { id: addressId, userId },
    });
    if (!address || !address.defaultAddress)
      throw new Error("Invalid or not a shipping address");

    const totalAmount = cart.cartItem.reduce(
      (sum, item) => sum + item.price,
      0
    );

    let finalAmount = totalAmount;
    let discountAmount = 0;
    let couponId: number | null = null;

    if (couponCode) {
      const coupon = await prisma.coupon.findFirst({
        where: { code: couponCode },
      });

      if (!coupon || coupon.isActive === false) {
        return res
          .status(400)
          .json({ error: "Invalid or Inactive coupon code " });
      }

      const now = new Date();
      if (now < coupon.validFrom || now > coupon.validTo) {
        return res
          .status(400)
          .json({ message: "Coupon expired or not yet valid" });
      }

      if (coupon.minOrderValue && totalAmount < coupon.minOrderValue) {
        return res
          .status(400)
          .json({ error: "Order does not meet coupon requirement" });
      }

      if (coupon.discountType === "PERCENTAGE") {
        discountAmount = (totalAmount * coupon.discountValue) / 100;
      } else if (coupon.discountType === "FIXED") {
        discountAmount = coupon.discountValue;
      }

      if (discountAmount > totalAmount) {
        return res
          .status(400)
          .json({ error: "Discount cannot exceed final amount" });
      }

      finalAmount = totalAmount - discountAmount;
      couponId = coupon.id;
    }

    // Transaction: order + stock decrement + clear cart
    const order = await prisma.$transaction(async (tx) => {
      // ðŸ”Ž Check stock for each cart item
      for (const item of cart.cartItem) {
        const sku = await tx.sku.findUnique({
          where: { id: item.skuId },
        });

        if (!sku || sku.stock < item.quantity) {
          throw new Error(
            `Not enough stock for SKU ${item.skuId} (requested ${item.quantity}, available ${sku?.stock ?? 0})`
          );
        }
      }

      // ðŸ“ Create order
      const newOrder = await tx.order.create({
        data: {
          userId,
          defaultAddress: address.id,
          couponId,
          totalAmount,
          discountAmount,
          finalAmount,
          orderItems: {
            create: cart.cartItem.map((item) => ({
              skuId: item.skuId,
              quantity: item.quantity,
              price: item.price,
            })),
          },
        },
        include: { orderItems: true, coupon: true },
      });

      // ðŸ“‰ Decrement stock
      for (const item of newOrder.orderItems) {
        await tx.sku.update({
          where: { id: item.skuId },
          data: {
            stock: { decrement: item.quantity },
          },
        });
      }

      // ðŸ§¹ Clear cart
      await tx.cartItems.deleteMany({ where: { cartId: cart.id } });

      return newOrder;
    });

    return res
      .status(201)
      .json({ message: "Order placed successfully", order });
  } catch (error) {
    next(error);
  }
};
    
    
// sms   
const accountSid = 'ACb0bb43104c2c21daebc0b0cedf226411';
const authToken = 'd2048fb3a27bd21e1509f92c6b70fd51';
const client = require('twilio')(accountSid, authToken);

client.verify.v2.services("VAe84d4d13ca3541f1639ecd0ccac2cf6c")
      .verifications
      .create({to: '+919594331924', channel: 'sms'})
      .then(verification => console.log(verification.sid));
    
    
    
    
import { Request, Response, NextFunction } from 'express';
import { prisma } from './prismaClient';  // Make sure to import your Prisma client
import twilio from 'twilio';

const accountSid = 'yourAccountSid';  // Your Twilio Account SID
const authToken = 'yourAuthToken';   // Your Twilio Auth Token
const client = twilio(accountSid, authToken);

// Twilio Verify Service SID (you must have this configured in your Twilio dashboard)
const verifyServiceSid = 'yourTwilioVerifyServiceSid';

export const verifyOtpSms = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Get the email or phone number of the user from the request (assume the user is logged in)
    const { email } = req.body;  // Or if you're using phone, { phone }

    // Retrieve the user from the database
    const user = await prisma.user.findUnique({
      where: {
        email: email,  // Or phone number if you're using phone number directly
      },
    });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    if (!user.phone) {
      return res.status(400).json({ message: 'User phone number is missing' });
    }

    const phoneNumber = user.phone;

    // Send OTP to user's phone using Twilio's Verify API
    const verification = await client.verify.v2.services(verifyServiceSid)
      .verifications
      .create({
        to: phoneNumber,  // Phone number from the database
        channel: 'sms',   // You can use 'sms' or 'email' based on the channel you prefer
      });

    // Check if verification was successful
    if (verification.status === 'pending') {
      return res.status(200).json({ message: 'OTP sent successfully' });
    }

    return res.status(500).json({ message: 'Failed to send OTP' });
    
  } catch (error) {
    console.error('Error sending OTP:', error);
    next(error);  // Forward the error to your error handling middleware
  }
};
   
    
 *               skus:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     attributes:
 *                       type: object
 *                     skuCode:
 *                       type: string
 *                     productPrice:
 *                       type: number
 *                     discount:
 *                       type: number
 *                     stock:
 *                       type: integer   